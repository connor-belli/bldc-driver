/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>


#include "printf.h"
#include "stm32f303xc.h"
#include "usart.h"
#include "MEMS.h"
#include <cmath>
#include "sin.h"
#include "bldc.h"

// Channel Pin
// 4       c9
// 3       c8
// 2       c7
// 1       c6
// 4       d6
// 3       d7
// High Low Phase
// 9,  8    1
// 7,  6    2
// 6,  7    3
void setup_bldc() {
	// Set pins c6-c9, d6, d7 to AF
	GPIOD->MODER |= 0xA << 12;
	GPIOC->MODER |= 0xAA << 12;
	// Set pins to high speed mode
	GPIOD->OSPEEDR |= 0xF << 12;
	GPIOC->OSPEEDR |= 0xFF << 12;
	// Set c6 - c9 AF to TIM 4
	GPIOC->AFR[0] |= 0x22 << 24;
	GPIOC->AFR[1] |= 0x22;
	// Set d6, d7 AF to TIM 2
	GPIOD->AFR[0] |= 0x22 << 24;

	// Set automatic reload to be 3600
	TIM2->ARR = 8912;//4096;
	TIM3->ARR = 8912;//4096;
	// Results in PWM with frequency of ~17.5khz from 72mhz clk

	// Send update event
	TIM2->EGR |= TIM_EGR_UG;
	TIM3->EGR |= TIM_EGR_UG;
	// Enable automatic reload
	TIM2->CR1 |= TIM_CR1_ARPE;
	TIM3->CR1 |= TIM_CR1_ARPE;

	// Enable PWM mode 1 on all channels
	TIM3->CCMR1 |= 0x6 << 4 | 0x6 << 12;
	TIM3->CCMR2 |= 0x6 << 4 | 0x6 << 12;
	// Enable PWM for 3, 4 on TIM 2
	TIM2->CCMR2 |= 0x6 << 4 | 0x6 << 12;
	// Enable pre-load
	TIM3->CCMR1 |= TIM_CCMR1_OC1PE | TIM_CCMR1_OC2PE;
	TIM3->CCMR2 |= TIM_CCMR2_OC3CE | TIM_CCMR2_OC4PE;
	TIM2->CCMR2 |= TIM_CCMR2_OC3CE | TIM_CCMR2_OC4PE;
	// Enable outputs
	TIM3->CCER |= TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E;
	TIM2->CCER |= TIM_CCER_CC3E | TIM_CCER_CC4E;

	// Invert polarity for Low channels
	TIM3->CCER |= TIM_CCER_CC1P | TIM_CCER_CC3P;
	TIM2->CCER |= TIM_CCER_CC3P;

	// Enable timers
	TIM2->CR1 |= TIM_CR1_CEN;
	TIM3->CR1 |= TIM_CR1_CEN;
}

void setup_bldc_comp() {
	// Use Comp 6
	// Neutral B11
	// 1 - B15, 2 - D10, 3 - A4

	// Set analog mode for pins
	GPIOB->MODER |= 0x3 << 30 | 0x3 << 22;
	GPIOD->MODER |= 0x3 << 20;
	GPIOA->MODER |= 0x3 << 8;

	// Invert comp
	COMP6->CSR |= 1 << 15;
	// Set neutral to B11
	COMP6->CSR |= 1 << 7;
	// Enable comparator
	COMP6->CSR |= COMP_CSR_COMPxEN;
}

void update_bldc(uint16_t micros) {
	// Determine which coil is primary phase
	// 0 = a+, 1 = b-, 2 = c+, 3 = a-, 4 = b+, 5 = c-
	int phase = micros / (UINT16_MAX / 6);
	// Not exact so phase 5 will be a little bigger than the other phases
	if(phase > 5) phase = 5;

	// Phases are 120 degrees apart
	constexpr uint16_t scale = 4;
	int16_t a = abs(fp_sin(micros)) / scale;
	int16_t b = abs(fp_sin(micros + UINT16_MAX / 3)) / scale;
	int16_t c = abs(fp_sin(micros + 2 * (UINT16_MAX / 3))) / scale;

	switch(phase) {
	case 0:
		a_primary<false>();
		b_secondary<false, true>(a, b);
		c_secondary<true, true>(a, c);
		break;
	case 1:
		b_primary<true>();
		a_secondary<false, false>(b, a);
		c_secondary<true, false>(b, c);
		break;
	case 2:
		c_primary<false>();
		a_secondary<false, true>(c, a);
		b_secondary<true, true>(c, b);
		break;
	case 3:
		a_primary<true>();
		b_secondary<false, false>(a, b);
		c_secondary<true, false>(a, c);
		break;
	case 4:
		b_primary<false>();
		a_secondary<false, true>(b, a);
		c_secondary<true, true>(b, c);
		break;
	default:
		c_primary<true>();
		a_secondary<false, false>(c, a);
		b_secondary<true, false>(c, b);
		break;
	}
}

void system_config(void) {
	// Enable RCC
	RCC->CR |= RCC_CR_HSEON;
	// Wait for RCC to become ready
	while(!(RCC->CR & RCC_CR_HSERDY));

	// Configure Power
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;

	// Configure Flash
	FLASH->ACR |= FLASH_ACR_PRFTBE;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;

	// Configure Clock
	RCC->CFGR |= RCC_CFGR_PLLSRC_HSE_PREDIV;
	RCC->CFGR |= RCC_CFGR_PLLMUL9;
	RCC->CFGR |= RCC_CFGR_USBPRE_DIV1_5;
	//RCC->CFGR |= RCC_CFGR_MCO_PLL;
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

	// Enable PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	// Configure System Clock
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);

	// Peripheral clocks
	RCC->AHBENR |= RCC_AHBENR_DMA1EN; // DMA1
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN; // GPIO A
	RCC->AHBENR |= RCC_AHBENR_GPIOBEN; // GPIO B
	RCC->AHBENR |= RCC_AHBENR_GPIOCEN; // GPIO C
	RCC->AHBENR |= RCC_AHBENR_GPIODEN; // GPIO D
	RCC->AHBENR |= RCC_AHBENR_GPIOEEN; // GPIO E
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN; // USART1
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN; // I2C1
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN; // TIM 2
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN; // TIM 3
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN; // SPI1
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; // SYSCFG
	// Enable FPU
	// Set CP11 and CP10 to full access
	SCB->CPACR |= 0xF << 20;
	// Clear pipeline
	__DSB();
	__ISB();
}

void delay_us(uint16_t us) {
	TIM6->CNT = 0;
	while(TIM6->CNT < us);
}

void delay_ms(uint16_t ms) {
	for(uint16_t i = 0; i < ms; i++) {
		delay_us(1000);
	}
}


int main(void)
{
	system_config();

	// Set all GPIOE pins to be digital out except for first 6
	GPIOE->MODER |= 0x55555040;
	GPIOE->OTYPER = 0;
	// Set all GPIOE to low speed
	GPIOE->OSPEEDR = 0;

	RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;
	TIM6->PSC |= 72-1;
	TIM6->ARR |= 0xFFFF;
	TIM6->CR1 |= TIM_CR1_CEN;
	while(!(TIM6->SR & TIM_SR_UIF));

	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
	TIM7->PSC |= 5000-1;
	TIM7->ARR |= UINT16_MAX - 1;
	TIM7->CR1 |= TIM_CR1_CEN;
	while(!(TIM7->SR & TIM_SR_UIF));

	// Initialize USART
	USART_init();
	setup_bldc();
	setup_bldc_comp();
	TIM6->CNT = 0;
	// Set COMP input to phase 1 - b15
	COMP6->CSR |= 0x7 << 4;
	for(;;) {
		update_bldc(TIM7->CNT);
		delay_us(50);
		//bool comp = (COMP6->CSR & COMP_CSR_COMPxOUT) != 0;
	}
}
